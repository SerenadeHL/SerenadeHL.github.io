{"meta":{"title":"Serenade's Blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"Android","date":"2021-05-08T04:53:07.000Z","updated":"2021-07-29T09:45:43.007Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Android","date":"2021-05-08T04:49:04.000Z","updated":"2021-07-29T09:45:43.008Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android系统启动流程","slug":"Android系统启动流程","date":"2021-08-04T07:38:26.000Z","updated":"2021-08-05T06:50:08.020Z","comments":true,"path":"2021/08/04/Android系统启动流程/","link":"","permalink":"http://example.com/2021/08/04/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"按下电源键 启动BootLoader 启动Linux内核 解析init.rc 启动Zygote 启动SystemServer sad","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/tags/Android/"}]},{"title":"阅读Android源码","slug":"Mac查看Android源码","date":"2021-08-02T10:40:26.000Z","updated":"2021-08-02T10:41:32.910Z","comments":true,"path":"2021/08/02/Mac查看Android源码/","link":"","permalink":"http://example.com/2021/08/02/Mac%E6%9F%A5%E7%9C%8BAndroid%E6%BA%90%E7%A0%81/","excerpt":"","text":"阅读Android源码 同步Android源码1.","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/tags/Android/"}]},{"title":"UI刷新机制","slug":"UI刷新机制","date":"2021-05-08T04:21:26.000Z","updated":"2021-07-29T09:45:43.007Z","comments":true,"path":"2021/05/08/UI刷新机制/","link":"","permalink":"http://example.com/2021/05/08/UI%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/","excerpt":"","text":"UI刷新机制 以下代码分析均基于Android9.0(API28) 我们从ViewRootImpl的requestLayout()方法开始 123456789public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; //检查是否是主线程 checkThread(); mLayoutRequested = true; //开启整个绘制流程 scheduleTraversals(); &#125;&#125; 可以看到requestLayout()方法调用了checkThread()，从名字我们可以看出这个方法是用来检查线程的，我们来看一下具体实现 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125;&#125; 看到这个异常信息是不是很熟悉？没错，如果我们在非主线程进行了修改UI的操作就会抛出这个异常，接下来我们继续看scheduleTraversals()方法 12345678910111213141516void scheduleTraversals() &#123; //mTraversalScheduled会在doTraversal重置成false，从而保证一段时间内只会执行一次绘制 if (!mTraversalScheduled) &#123; mTraversalScheduled = true; //开启同步屏障，优先处理绘制操作 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //发送绘制消息 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 可以看到，该方法先是开启了同步屏障，因为接下来会有大量的异步消息发送，然后向Choreographer发送了mTraversalRunnable，我们先来看一下postCallback()发送消息的代码 123456789101112131415161718192021222324252627282930313233343536373839public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; if (action == null) &#123; throw new IllegalArgumentException(&quot;action must not be null&quot;); &#125; if (callbackType &lt; 0 || callbackType &gt; CALLBACK_LAST) &#123; throw new IllegalArgumentException(&quot;callbackType is invalid&quot;); &#125; postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;PostCallback: type=&quot; + callbackType + &quot;, action=&quot; + action + &quot;, token=&quot; + token + &quot;, delayMillis=&quot; + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); //如果action的执行的时间小于等于当前时间，则直接执行 if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 可以看到postCallback()最终调到了postCallbackDelayedInternal()方法，然后把Runnable按type加到了CallbackQueue里，如果Runnable要执行的时间小于等于当前时间，则直接执行，否则发送Message延时执行，找一下处理Message的地方 123456789101112131415161718192021222324public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME: doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync(); break; case MSG_DO_SCHEDULE_CALLBACK: doScheduleCallback(msg.arg1); break; &#125;&#125;void doScheduleCallback(int callbackType) &#123; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; final long now = SystemClock.uptimeMillis(); if (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123; scheduleFrameLocked(now); &#125; &#125; &#125;&#125; 可以看到最终也是调用的scheduleFrameLocked()方法，那我们就看一下这个方法里都做了些什么 123456789101112131415161718192021222324252627282930private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;Scheduling next frame on vsync.&quot;); &#125; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;Scheduling next frame in &quot; + (nextFrameTime - now) + &quot; ms.&quot;); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 这里有一个USE_VSYNC是否使用VSYNC的判断，而USE_VSYNC的值是从系统读取出来的，默认值为true，从这里可以看出，使用VSYNC的话会判断是否是UI线程，是的话直接执行，不是的话通过Handler发送MSG_DO_SCHEDULE_VSYNC执行，而不使用VSYNC的话是通过Handler发送了MSG_DO_FRAME执行，找一下处理这两个消息的地方 1234567891011121314151617181920212223242526272829303132private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME: doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync(); break; case MSG_DO_SCHEDULE_CALLBACK: doScheduleCallback(msg.arg1); break; &#125; &#125;&#125;void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; scheduleVsyncLocked(); &#125; &#125;&#125;private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();&#125; 可以看到MSG_DO_SCHEDULE_VSYNC消息最终调用到了mDisplayEventReceiver的scheduleVsync()方法，mDisplayEventReceiver对应的类是FrameDisplayEventReceiver 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123; private boolean mHavePendingVsync; private long mTimestampNanos; private int mFrame; public FrameDisplayEventReceiver(Looper looper, int vsyncSource) &#123; super(looper, vsyncSource); &#125; @Override public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; // Ignore vsync from secondary display. // This can be problematic because the call to scheduleVsync() is a one-shot. // We need to ensure that we will still receive the vsync from the primary // display which is the one we really care about. Ideally we should schedule // vsync for a particular display. // At this time Surface Flinger won&#x27;t send us vsyncs for secondary displays // but that could change in the future so let&#x27;s log a message to help us remember // that we need to fix this. if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123; Log.d(TAG, &quot;Received vsync from secondary display, but we don&#x27;t support &quot; + &quot;this case yet. Choreographer needs a way to explicitly request &quot; + &quot;vsync for a specific display to ensure it doesn&#x27;t lose track &quot; + &quot;of its scheduled vsync.&quot;); scheduleVsync(); return; &#125; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f) + &quot; ms in the future! Check that graphics HAL is generating vsync &quot; + &quot;timestamps using the correct timebase.&quot;); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, &quot;Already have a pending vsync event. There should only be &quot; + &quot;one at a time.&quot;); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); &#125; @Override public void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame); &#125;&#125; 可以看到FrameDisplayEventReceiver类里没有scheduleVsync()方法，那就是在他爹DisplayEventReceiver里了 1234567891011121314/** * Schedules a single vertical sync pulse to be delivered when the next * display frame begins. */public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, &quot;Attempted to schedule a vertical sync pulse but the display event &quot; + &quot;receiver has already been disposed.&quot;); &#125; else &#123; nativeScheduleVsync(mReceiverPtr); &#125;&#125;private static native void nativeScheduleVsync(long receiverPtr); 果然在DisplayEventReceiver里找到了对应方法，根据注释和名字可以得出这个方法是注册一个VSYNC刷新监听，他的回调是onVsync() 12345678910111213/** * Called when a vertical sync pulse is received. * The recipient should render a frame and then call &#123;@link #scheduleVsync&#125; * to schedule the next vertical sync pulse. * * @param timestampNanos The timestamp of the pulse, in the &#123;@link System#nanoTime()&#125; * timebase. * @param builtInDisplayId The surface flinger built-in display id such as * &#123;@link SurfaceControl#BUILT_IN_DISPLAY_ID_MAIN&#125;. * @param frame The frame number. Increases by one for each vertical sync interval. */public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;&#125; 诶？怎么是个空方法，那必然是子类重写了该方法实现了一些具体的逻辑，回到刚刚那个FrameDisplayEventReceiver类，可以看到果然重写了onVsync() 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overridepublic void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; // Ignore vsync from secondary display. // This can be problematic because the call to scheduleVsync() is a one-shot. // We need to ensure that we will still receive the vsync from the primary // display which is the one we really care about. Ideally we should schedule // vsync for a particular display. // At this time Surface Flinger won&#x27;t send us vsyncs for secondary displays // but that could change in the future so let&#x27;s log a message to help us remember // that we need to fix this. if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123; Log.d(TAG, &quot;Received vsync from secondary display, but we don&#x27;t support &quot; + &quot;this case yet. Choreographer needs a way to explicitly request &quot; + &quot;vsync for a specific display to ensure it doesn&#x27;t lose track &quot; + &quot;of its scheduled vsync.&quot;); scheduleVsync(); return; &#125; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f) + &quot; ms in the future! Check that graphics HAL is generating vsync &quot; + &quot;timestamps using the correct timebase.&quot;); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, &quot;Already have a pending vsync event. There should only be &quot; + &quot;one at a time.&quot;); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);&#125; 可以看到里面就是发送了一个定时消息，然后执行的Runnable是自身，那我们看一下run()方法 12345@Overridepublic void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame);&#125; 诶？doFrame()？看着有点眼熟啊，这不是刚刚分叉那个地方另外一个分支调用的方法吗，到这统一了，那就看看doFrame()里具体干了什么 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; return; // no work to do &#125; if (DEBUG_JANK &amp;&amp; mDebugPrintNextFrameTimeDelta) &#123; mDebugPrintNextFrameTimeDelta = false; Log.d(TAG, &quot;Frame time delta: &quot; + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + &quot; ms&quot;); &#125; long intendedFrameTimeNanos = frameTimeNanos; startNanos = System.nanoTime(); //注释1 final long jitterNanos = startNanos - frameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) &#123; final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123; Log.i(TAG, &quot;Skipped &quot; + skippedFrames + &quot; frames! &quot; + &quot;The application may be doing too much work on its main thread.&quot;); &#125; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; if (DEBUG_JANK) &#123; Log.d(TAG, &quot;Missed vsync by &quot; + (jitterNanos * 0.000001f) + &quot; ms &quot; + &quot;which is more than the frame interval of &quot; + (mFrameIntervalNanos * 0.000001f) + &quot; ms! &quot; + &quot;Skipping &quot; + skippedFrames + &quot; frames and setting frame &quot; + &quot;time to &quot; + (lastFrameOffset * 0.000001f) + &quot; ms in the past.&quot;); &#125; frameTimeNanos = startNanos - lastFrameOffset; &#125; if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123; if (DEBUG_JANK) &#123; Log.d(TAG, &quot;Frame time appears to be going backwards. May be due to a &quot; + &quot;previously skipped frame. Waiting for next vsync.&quot;); &#125; scheduleVsyncLocked(); return; &#125; if (mFPSDivisor &gt; 1) &#123; long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos; if (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; 0) &#123; scheduleVsyncLocked(); return; &#125; &#125; mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); mFrameScheduled = false; mLastFrameTimeNanos = frameTimeNanos; &#125; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;Choreographer#doFrame&quot;); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); //注释2 mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; if (DEBUG_FRAMES) &#123; final long endNanos = System.nanoTime(); Log.d(TAG, &quot;Frame &quot; + frame + &quot;: Finished, took &quot; + (endNanos - startNanos) * 0.000001f + &quot; ms, latency &quot; + (startNanos - frameTimeNanos) * 0.000001f + &quot; ms.&quot;); &#125;&#125; 先看注释1的地方，这里由于frameTimeNanos是收到VSYNC后通过Handler发送的异步消息，而Handler是一个按时间排序的优先级队列，如果前一个任务执行耗时过长，后一个任务并不会按设置的时间精准执行，会延后执行，想象一下，我收到VSYNC消息后要重新渲染页面了，但是由于前面任务太耗时导致我渲染晚了，这期间屏幕显示的还是上一帧的内容，那我不就掉帧了吗，所以要用真正开始执行的时间减去发消息时的时间(VSYNC)时间，得到的差值除以刷新周期，就是掉了多少帧，这里能看到如果掉帧数大于SKIPPED_FRAME_WARNING_LIMIT，则会输出一个Log警告 再看注释2的地方，这里调用了一堆markXXXStart()和doCallback()方法，我们先看一下markXXXStart()方法干了什么 1234567891011public void markInputHandlingStart() &#123; mFrameInfo[HANDLE_INPUT_START] = System.nanoTime();&#125;public void markAnimationsStart() &#123; mFrameInfo[ANIMATION_START] = System.nanoTime();&#125;public void markPerformTraversalsStart() &#123; mFrameInfo[PERFORM_TRAVERSALS_START] = System.nanoTime();&#125; 可以看到只是更新了对应标记的时间，这个操作也很对的起FrameInfo这个类的名字哈哈，再看一下doCallback()里干了什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; // We use &quot;now&quot; to determine when callbacks become due because it&#x27;s possible // for earlier processing phases in a frame to post callbacks that should run // in a following phase, such as an input event that causes an animation to start. final long now = System.nanoTime(); //按对应type获取指定时间之前的CallbackRecord链表头结点 callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS); if (callbacks == null) &#123; return; &#125; mCallbacksRunning = true; // Update the frame time if necessary when committing the frame. // We only update the frame time if we are more than 2 frames late reaching // the commit phase. This ensures that the frame time which is observed by the // callbacks will always increase from one frame to the next and never repeat. // We never want the next frame&#x27;s starting frame time to end up being less than // or equal to the previous frame&#x27;s commit frame time. Keep in mind that the // next frame has most likely already been scheduled by now so we play it // safe by ensuring the commit time is always at least one frame behind. if (callbackType == Choreographer.CALLBACK_COMMIT) &#123; final long jitterNanos = now - frameTimeNanos; Trace.traceCounter(Trace.TRACE_TAG_VIEW, &quot;jitterNanos&quot;, (int) jitterNanos); if (jitterNanos &gt;= 2 * mFrameIntervalNanos) &#123; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos + mFrameIntervalNanos; if (DEBUG_JANK) &#123; Log.d(TAG, &quot;Commit callback delayed by &quot; + (jitterNanos * 0.000001f) + &quot; ms which is more than twice the frame interval of &quot; + (mFrameIntervalNanos * 0.000001f) + &quot; ms! &quot; + &quot;Setting frame time to &quot; + (lastFrameOffset * 0.000001f) + &quot; ms in the past.&quot;); mDebugPrintNextFrameTimeDelta = true; &#125; frameTimeNanos = now - lastFrameOffset; mLastFrameTimeNanos = frameTimeNanos; &#125; &#125; &#125; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]); for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;RunCallback: type=&quot; + callbackType + &quot;, action=&quot; + c.action + &quot;, token=&quot; + c.token + &quot;, latencyMillis=&quot; + (SystemClock.uptimeMillis() - c.dueTime)); &#125; c.run(frameTimeNanos); &#125; &#125; finally &#123; synchronized (mLock) &#123; mCallbacksRunning = false; do &#123; final CallbackRecord next = callbacks.next; recycleCallbackLocked(callbacks); callbacks = next; &#125; while (callbacks != null); &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 可以看到这里按对应type类型获取了指定时间之前的CallbackRecord链表头结点，然后遍历执行了run()方法，看下run()方法实现 1234567public void run(long frameTimeNanos) &#123; if (token == FRAME_CALLBACK_TOKEN) &#123; ((FrameCallback)action).doFrame(frameTimeNanos); &#125; else &#123; ((Runnable)action).run(); &#125;&#125; token为FRAME_CALLBACK_TOKEN时强转为FrameCallback执行了doFrame()方法，不是的时候强转为Runnable执行了run()方法，还记得我们当初为什么进入Choreographer类吗，是因为mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);这里发送了一个Callback，这个发送最终会调用postCallbackDelayedInternal()方法，我们回去看下发送的代码 1234567891011121314151617181920212223private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;PostCallback: type=&quot; + callbackType + &quot;, action=&quot; + action + &quot;, token=&quot; + token + &quot;, delayMillis=&quot; + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 可以看到我们往mCallbackQueues里按type添加了Callback，而通过发送地方传的参数可以看出token为null，那么刚刚遍历执行的分支就会命中else分支，强转为Runnable执行run()方法，而我们传入的是mTraversalRunnable，找下声明的地方 1234567final TraversalRunnable mTraversalRunnable = new TraversalRunnable();final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125; mTraversalRunnable实现很简单，单纯的调用了一下doTraversal()，我们接下来来看doTraversal()方法 12345678910111213141516171819void doTraversal() &#123; if (mTraversalScheduled) &#123; //重置标志，以便下次再次开启绘制流程 mTraversalScheduled = false; //移除之前开启的同步屏障，同步屏障的添加和移除必须是成对出现的 mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(&quot;ViewAncestor&quot;); &#125; //真正开始执行绘制流程的地方 performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; 可以看到在doTraversal()方法中，首先是重置了mTraversalScheduled标志，让下次scheduleTraversals()不会被挡掉，然后移除了同步屏障，最后调用了performTraversals()方法，这里就是我们熟知的measure、layout、draw的地方了","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/tags/Android/"}]},{"title":"Activity显示流程","slug":"Activity显示流程","date":"2021-05-08T04:21:26.000Z","updated":"2021-08-08T15:53:24.006Z","comments":true,"path":"2021/05/08/Activity显示流程/","link":"","permalink":"http://example.com/2021/05/08/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Activity显示流程1234override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)&#125; 上面这段代码是我们新建项目适合默认创建的，我们来看一下setContentView()究竟做了什么能让页面显示出来，点进去看一眼 12345678910111213/** * Set the activity content from a layout resource. The resource will be * inflated, adding all top-level views to the activity. * * @param layoutResID Resource ID to be inflated. * * @see #setContentView(android.view.View) * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams) */public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; 可以看到，调用了了getWindow()的setContentView()方法，那我们看一下getWindow()拿到的是什么 1234567891011/** * Retrieve the current &#123;@link android.view.Window&#125; for the activity. * This can be used to directly access parts of the Window API that * are not available through Activity/Screen. * * @return Window The current window, or null if the activity is not * visual. */public Window getWindow() &#123; return mWindow;&#125; getDelegate()返回的是mWindow，我们看一下mWindow是什么类型以及在哪初始化的 123456789101112131415private Window mWindow;final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; //省略部分代码 ... mWindow = new PhoneWindow(this, window, activityConfigCallback); //省略部分代码 ...&#125; 可以看到mWindow实际上是PhoneWindow，那就来看看PhoneWindow的setContentView()方法 1234567891011121314151617181920212223242526@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. //注释1 if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 我们先来看注释1的地方，此处判断了mContentParent是否存在，如果不存在则调用installDecor()方法，找一下mContentParent赋值的地方发现只有一处，就是installDecor()方法，我们点进去看一眼 123456789101112131415private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); //省略部分代码 ... &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); //省略部分代码 ... &#125;&#125; 可以看到里面的逻辑也很简单，mDecor没有的话就generate一个，mContentParent没有的话也generate一个，先看一下mDecor的生成 1234567891011121314151617181920protected DecorView generateDecor(int featureId) &#123; // System process doesn&#x27;t have application context and in that case we need to directly use // the context we have. Otherwise we want the application context, so we don&#x27;t cling to the // activity. Context context; if (mUseDecorContext) &#123; Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) &#123; context = getContext(); &#125; else &#123; context = new DecorContext(applicationContext, getContext()); if (mTheme != -1) &#123; context.setTheme(mTheme); &#125; &#125; &#125; else &#123; context = getContext(); &#125; return new DecorView(context, featureId, this, getAttributes());&#125; 逻辑很简单，直接new了一个DecorView返回回来了，我们再看一下mContentParent的生成 12345678910111213141516171819202122232425262728293031323334353637383940414243protected ViewGroup generateLayout(DecorView decor) &#123; //省略部分代码 int layoutResource; int features = getLocalFeatures(); if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; layoutResource = R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; if (mIsFloating) &#123; layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; layoutResource = R.layout.screen_simple; &#125; mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(&quot;Window couldn&#x27;t find content container view&quot;); &#125; //省略部分代码 return contentParent;&#125; 可以看到mContentParent即为contentParent，是直接通过findViewById查找id为ID_ANDROID_CONTENT(com.android.internal.R.id.content)查找出来的，诶？window也有findViewById方法吗，看一眼咋写的 1234567891011121314151617181920/** * Finds a view that was identified by the &#123;@code android:id&#125; XML attribute * that was processed in &#123;@link android.app.Activity#onCreate&#125;. * &lt;p&gt; * This will implicitly call &#123;@link #getDecorView&#125; with all of the associated side-effects. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support -- * the resulting view is automatically cast to the target class type. If * the target class type is unconstrained, an explicit cast may be * necessary. * * @param id the ID to search for * @return a view with given ID if found, or &#123;@code null&#125; otherwise * @see View#findViewById(int) * @see Window#requireViewById(int) */@Nullablepublic &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; return getDecorView().findViewById(id);&#125; 可以看到直接调用的DecorView的findViewById，这里我们回到PhoneWindow的getDecorView方法 1234567@Overridepublic final @NonNull View getDecorView() &#123; if (mDecor == null || mForceDecorInstall) &#123; installDecor(); &#125; return mDecor;&#125; 其实不用看也可以猜出，返回的就是我们刚刚看到的那个mDecor，等等，好像哪里有点不对，mDecor不是刚刚new出来的吗？，难道它里面默认添加了子布局？我们快速回去看一眼 123456789101112131415161718192021222324252627282930DecorView(Context context, int featureId, PhoneWindow window, WindowManager.LayoutParams params) &#123; super(context); mFeatureId = featureId; mShowInterpolator = AnimationUtils.loadInterpolator(context, android.R.interpolator.linear_out_slow_in); mHideInterpolator = AnimationUtils.loadInterpolator(context, android.R.interpolator.fast_out_linear_in); mBarEnterExitDuration = context.getResources().getInteger( R.integer.dock_enter_exit_duration); mForceWindowDrawsBarBackgrounds = context.getResources().getBoolean( R.bool.config_forceWindowDrawsStatusBarBackground) &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= N; mSemiTransparentBarColor = context.getResources().getColor( R.color.system_bar_background_semi_transparent, null /* theme */); updateAvailableWidth(); setWindow(window); updateLogTag(params); mResizeShadowSize = context.getResources().getDimensionPixelSize( R.dimen.resize_shadow_size); initResizingPaints(); mLegacyNavigationBarBackgroundPaint.setColor(Color.BLACK);&#125; 这里面也没有添加子布局的代码啊？那一定是后add进去的，还记得刚刚findViewById之前有个方法叫onResourcesLoaded吗？进去看一下 1234567891011121314151617181920212223242526void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; if (mBackdropFrameRenderer != null) &#123; loadBackgroundDrawablesIfNeeded(); mBackdropFrameRenderer.onResourcesLoaded( this, mResizingBackgroundDrawable, mCaptionBackgroundDrawable, mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState), getCurrentColor(mNavigationColorViewState)); &#125; mDecorCaptionView = createDecorCaptionView(inflater); final View root = inflater.inflate(layoutResource, null); if (mDecorCaptionView != null) &#123; if (mDecorCaptionView.getParent() == null) &#123; addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; else &#123; // Put it below the color views. addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mContentRoot = (ViewGroup) root; initializeElevation();&#125; 果然是在这里addView的，那么这个根据layoutResourceinflate出来的root里一定是有刚刚的id，我们看下这个layoutResource传进来的值是多少，回到刚刚的generateLayout方法 12345678910111213141516171819202122232425262728293031323334353637383940414243protected ViewGroup generateLayout(DecorView decor) &#123; //省略部分代码 int layoutResource; int features = getLocalFeatures(); if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; layoutResource = R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; if (mIsFloating) &#123; layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; layoutResource = R.layout.screen_simple; &#125; mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(&quot;Window couldn&#x27;t find content container view&quot;); &#125; //省略部分代码 return contentParent;&#125; 可以看到layoutResource是根据一堆条件判断出来的，我们随便取其中的R.layout.screen_simple看下 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 可以看到确实是存在id为content的子布局，到这里我们就把installDecor()的整个流程分析完了，我们回到setContentView方法 12345678910111213141516171819202122232425@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 我们可以看到判断了是否有FEATURE_CONTENT_TRANSITIONS这个Feature，这个是跟动画相关的，我们直接看else，else里的操作很简单，就是调用了mLayoutInflater把layoutResID布局加载到我们刚刚初始化的mContentParent里去，我们看一下他到底是怎么加载的布局 123456789101112131415161718192021222324252627282930313233343536/** * Inflate a new view hierarchy from the specified xml resource. Throws * &#123;@link InflateException&#125; if there is an error. * * @param resource ID for an XML layout resource to load (e.g., * &lt;code&gt;R.layout.main_page&lt;/code&gt;) * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); &#125; View view = tryInflatePrecompiled(resource, res, root, attachToRoot); if (view != null) &#123; return view; &#125; XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 点进去发现inflate有好多重载方法，最终调用的是上面这个方法，可以看到这里有一步优化，tryInflatePrecompiled这个方法顾名思义，尝试实例化已经预编译的，我们先不管这个预编译，直接看没有预编译的情况，这里获取了XmlResourceParser传入到了inflate方法，并且把inflate的结果返回回去了，那么这个inflate应该就是进行我们布局xml解析的地方了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * Inflate a new view hierarchy from the specified XML node. Throws * &#123;@link InflateException&#125; if there is an error. * &lt;p&gt; * &lt;em&gt;&lt;strong&gt;Important&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;For performance * reasons, view inflation relies heavily on pre-processing of XML files * that is done at build time. Therefore, it is not currently possible to * use LayoutInflater with an XmlPullParser over a plain XML file at runtime. * * @param parser XML dom node containing the description of the view * hierarchy. * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; advanceToRootNode(parser); final String name = parser.getName(); if (DEBUG) &#123; System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); &#125; if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println(&quot;Creating params from root: &quot; + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println(&quot;-----&gt; start inflating children&quot;); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println(&quot;-----&gt; done inflating children&quot;); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; final InflateException ie = new InflateException(e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException( getParserStateDescription(inflaterContext, attrs) + &quot;: &quot; + e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; finally &#123; // Don&#x27;t retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; return result; &#125;&#125; 可以看到这里有一个判断，如果标签名是merge的话走的是rInflate方法，其他情况走rInflateChildren方法，我们先不管merge标签的情况，直接看rInflateChildren 1234567891011/** * Recursive method used to inflate internal (non-root) children. This * method calls through to &#123;@link #rInflate&#125; using the parent context as * the inflation context. * &lt;strong&gt;Note:&lt;/strong&gt; Default visibility so the BridgeInflater can * call it. */final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; rInflate(parser, parent, parent.getContext(), attrs, finishInflate);&#125; 可以看到rInflateChildren调用的也是rInflate方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Recursive method used to descend down the xml hierarchy and instantiate * views, instantiate their children, and then call onFinishInflate(). * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; Default visibility so the BridgeInflater can * override it. */void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; pendingRequestFocus = true; consumeChildElements(parser); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123; throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); &#125; else &#123; final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; if (pendingRequestFocus) &#123; parent.restoreDefaultFocus(); &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125; 可以看到这个while循环就是我们要找的东西了，在里面判断了各种标签requestFocus、tag、include、merge，最后的else才是真正解析TextView等控件的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * Convenience method for calling through to the five-arg createViewFromTag * method. This method passes &#123;@code false&#125; for the &#123;@code ignoreThemeAttr&#125; * argument and should be used for everything except &#123;@code &amp;gt;include&gt;&#125; * tag parsing. */@UnsupportedAppUsageprivate View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123; return createViewFromTag(parent, name, context, attrs, false);&#125;/** * Creates a view from a tag name using the supplied attribute set. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; Default visibility so the BridgeInflater can * override it. * * @param parent the parent view, used to inflate layout params * @param name the name of the XML tag used to define the view * @param context the inflation context for the view, typically the * &#123;@code parent&#125; or base layout inflater context * @param attrs the attribute set for the XML tag used to define the view * @param ignoreThemeAttr &#123;@code true&#125; to ignore the &#123;@code android:theme&#125; * attribute (if set) for the view being inflated, * &#123;@code false&#125; otherwise */@UnsupportedAppUsageView createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals(&quot;view&quot;)) &#123; name = attrs.getAttributeValue(null, &quot;class&quot;); &#125; // Apply a theme wrapper, if allowed and one is specified. if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; try &#123; View view = tryCreateView(parent, name, context, attrs); if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf(&#x27;.&#x27;)) &#123; view = onCreateView(context, parent, name, attrs); &#125; else &#123; view = createView(context, name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; catch (InflateException e) &#123; throw e; &#125; catch (ClassNotFoundException e) &#123; final InflateException ie = new InflateException( getParserStateDescription(context, attrs) + &quot;: Error inflating class &quot; + name, e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException( getParserStateDescription(context, attrs) + &quot;: Error inflating class &quot; + name, e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125;&#125; 注意这个地方的开头 有一个解析view标签的地方，注意这个view是小写的，不是我们经常用的那个&lt;View/&gt;，而是&lt;view&gt;，之前没用过，试了下还真可以 123456&lt;view class=&quot;android.widget.TextView&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot;/&gt; 用法跟直接用好像差不多，不过我只在xml里预览了一下，没有实际运行来看，不知道这个标签有什么用，我们继续往下看try里面的内容，这里我把代码单独粘贴出来 123456789101112131415View view = tryCreateView(parent, name, context, attrs);if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf(&#x27;.&#x27;)) &#123; view = onCreateView(context, parent, name, attrs); &#125; else &#123; view = createView(context, name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125;&#125; 可以看到先是调用tryCreateView尝试创建View，我们看下这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Tries to create a view from a tag name using the supplied attribute set. * * This method gives the factory provided by &#123;@link LayoutInflater#setFactory&#125; and * &#123;@link LayoutInflater#setFactory2&#125; a chance to create a view. However, it does not apply all * of the general view creation logic, and thus may return &#123;@code null&#125; for some tags. This * method is used by &#123;@link LayoutInflater#inflate&#125; in creating &#123;@code View&#125; objects. * * @hide for use by precompiled layouts. * * @param parent the parent view, used to inflate layout params * @param name the name of the XML tag used to define the view * @param context the inflation context for the view, typically the * &#123;@code parent&#125; or base layout inflater context * @param attrs the attribute set for the XML tag used to define the view */@UnsupportedAppUsage(trackingBug = 122360734)@Nullablepublic final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; if (name.equals(TAG_1995)) &#123; // Let&#x27;s party like it&#x27;s 1995! return new BlinkLayout(context, attrs); &#125; View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; return view;&#125; 可以看到这里先是判断了标签名是否是TAG_1995这个常量，下面还有一句注释，感觉这里像一个彩蛋，继续往下看，如果设置了mFactory2的话就用mFactory2创建view，否则如果设置了mFactory的话就用mFactory创建view，两个都没设置的话view为null，再看是否设置了mPrivateFactory，如果mPrivateFactory也没设置的话，会返回null，我们来看下这几个东西到底是什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private Factory mFactory;private Factory2 mFactory2;private Factory2 mPrivateFactory;/** * Attach a custom Factory interface for creating views while using * this LayoutInflater. This must not be null, and can only be set once; * after setting, you can not change the factory. This is * called on each element name as the xml is parsed. If the factory returns * a View, that is added to the hierarchy. If it returns null, the next * factory default &#123;@link #onCreateView&#125; method is called. * * &lt;p&gt;If you have an existing * LayoutInflater and want to add your own factory to it, use * &#123;@link #cloneInContext&#125; to clone the existing instance and then you * can use this function (once) on the returned new instance. This will * merge your own factory with whatever factory the original instance is * using. */public void setFactory(Factory factory) &#123; if (mFactorySet) &#123; throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;); &#125; if (factory == null) &#123; throw new NullPointerException(&quot;Given factory can not be null&quot;); &#125; mFactorySet = true; if (mFactory == null) &#123; mFactory = factory; &#125; else &#123; mFactory = new FactoryMerger(factory, null, mFactory, mFactory2); &#125;&#125;/** * Like &#123;@link #setFactory&#125;, but allows you to set a &#123;@link Factory2&#125; * interface. */public void setFactory2(Factory2 factory) &#123; if (mFactorySet) &#123; throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;); &#125; if (factory == null) &#123; throw new NullPointerException(&quot;Given factory can not be null&quot;); &#125; mFactorySet = true; if (mFactory == null) &#123; mFactory = mFactory2 = factory; &#125; else &#123; mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2); &#125;&#125;@UnsupportedAppUsagepublic void setPrivateFactory(Factory2 factory) &#123; if (mPrivateFactory == null) &#123; mPrivateFactory = factory; &#125; else &#123; mPrivateFactory = new FactoryMerger(factory, factory, mPrivateFactory, mPrivateFactory); &#125;&#125; 根据setFactory、setFactory2的注释可以得出，Factory会在系统解析每个View之前调用，有点类似于一个拦截器，众所周知系统解析布局是反射生成View的，而反射是耗时的，我们可以在这里自定义自己的Factory，直接返回new出来的View来节省反射这步的时间，但是要注意，Factory只能设置一次，再次设置会抛出异常，所以采用设置Factory方案的框架只能使用一个，我们接下来看如果Factory没有设置的情况，这里我们还是把代码粘贴出来 12345if (-1 == name.indexOf(&#x27;.&#x27;)) &#123; view = onCreateView(context, parent, name, attrs);&#125; else &#123; view = createView(context, name, null, attrs);&#125; 这里有个判断是标签名里是否含有.，为什么会这么判断呢，我们先看下如果标签名含.的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * Low-level function for instantiating a view by name. This attempts to * instantiate a view class of the given &lt;var&gt;name&lt;/var&gt; found in this * LayoutInflater&#x27;s ClassLoader. * * &lt;p&gt; * There are two things that can happen in an error case: either the * exception describing the error will be thrown, or a null will be * returned. You must deal with both possibilities -- the former will happen * the first time createView() is called for a class of a particular name, * the latter every time there-after for that class name. * * @param viewContext The context used as the context parameter of the View constructor * @param name The full name of the class to be instantiated. * @param attrs The XML attributes supplied for this instance. * * @return View The newly instantiated view, or null. */@Nullablepublic final View createView(@NonNull Context viewContext, @NonNull String name, @Nullable String prefix, @Nullable AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; Objects.requireNonNull(viewContext); Objects.requireNonNull(name); Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); if (constructor == null) &#123; // Class not found in the cache, see if it&#x27;s real, and try to add it clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) &#123; boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) &#123; failNotAllowed(name, prefix, viewContext, attrs); &#125; &#125; constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); &#125; else &#123; // If we have a filter, apply it to cached constructor if (mFilter != null) &#123; // Have we seen this name before? Boolean allowedState = mFilterMap.get(name); if (allowedState == null) &#123; // New class -- remember whether it is allowed clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz); mFilterMap.put(name, allowed); if (!allowed) &#123; failNotAllowed(name, prefix, viewContext, attrs); &#125; &#125; else if (allowedState.equals(Boolean.FALSE)) &#123; failNotAllowed(name, prefix, viewContext, attrs); &#125; &#125; &#125; Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = viewContext; Object[] args = mConstructorArgs; args[1] = attrs; try &#123; final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123; // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; return view; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; catch (NoSuchMethodException e) &#123; final InflateException ie = new InflateException( getParserStateDescription(viewContext, attrs) + &quot;: Error inflating class &quot; + (prefix != null ? (prefix + name) : name), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (ClassCastException e) &#123; // If loaded class is not a View subclass final InflateException ie = new InflateException( getParserStateDescription(viewContext, attrs) + &quot;: Class is not a View &quot; + (prefix != null ? (prefix + name) : name), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (ClassNotFoundException e) &#123; // If loadClass fails, we should propagate the exception. throw e; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException( getParserStateDescription(viewContext, attrs) + &quot;: Error inflating class &quot; + (clazz == null ? &quot;&lt;unknown&gt;&quot; : clazz.getName()), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 这里先从sConstructorMap查找了constructor的缓存，没找到的话调用Class.forName找到对应的类，然后获取对应类的constructor并缓存到sConstructorMap里，接下来反射调用构造方法构造出View实例，这样我们就获取到了我们xml中声明的View，接下来我们看下标签名不含.的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Version of &#123;@link #onCreateView(View, String, AttributeSet)&#125; that also * takes the inflation context. The default * implementation simply calls &#123;@link #onCreateView(View, String, AttributeSet)&#125;. * * @param viewContext The Context to be used as a constructor parameter for the View * @param parent The future parent of the returned view. &lt;em&gt;Note that * this may be null.&lt;/em&gt; * @param name The fully qualified class name of the View to be create. * @param attrs An AttributeSet of attributes to apply to the View. * * @return View The View created. */@Nullablepublic View onCreateView(@NonNull Context viewContext, @Nullable View parent, @NonNull String name, @Nullable AttributeSet attrs) throws ClassNotFoundException &#123; return onCreateView(parent, name, attrs);&#125;/** * Version of &#123;@link #onCreateView(String, AttributeSet)&#125; that also * takes the future parent of the view being constructed. The default * implementation simply calls &#123;@link #onCreateView(String, AttributeSet)&#125;. * * @param parent The future parent of the returned view. &lt;em&gt;Note that * this may be null.&lt;/em&gt; * @param name The fully qualified class name of the View to be create. * @param attrs An AttributeSet of attributes to apply to the View. * * @return View The View created. */protected View onCreateView(View parent, String name, AttributeSet attrs) throws ClassNotFoundException &#123; return onCreateView(name, attrs);&#125;/** * This routine is responsible for creating the correct subclass of View * given the xml element name. Override it to handle custom view objects. If * you override this in your subclass be sure to call through to * super.onCreateView(name) for names you do not recognize. * * @param name The fully qualified class name of the View to be create. * @param attrs An AttributeSet of attributes to apply to the View. * * @return View The View created. */protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123; return createView(name, &quot;android.view.&quot;, attrs);&#125; 可以看到也是调用的相同方法，只是前缀默认拼上了android.view.，我们自己包名的控件拼接上这个肯定就找不到了，所以这个是系统控件，如TextView等会变成android.view.TextView，到这里我们就把整个setContentView的流程梳理完了。","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/tags/Android/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/source/tags/Android/"}]}